# 1.二进制

## 1. 位运算

| 操作符 | 作用     |
| ------ | -------- |
| &      | 按位与   |
| \|     | 按位或   |
| ^      | 按位异或 |
| ~      | 取反     |
| <<     | 左移     |
| >>     | 右移     |

### 1.1 按位与运算`&`

运算规则：两位同时为`1`，结果才为`1`，否则为`0`

**性质**：

1. 任何数与0与运算，结果都为0
2. 每一位同1与运算，值不变

**作用**：

1. **清零**：将数与0与运算
2. **取一个数的指定位**:
     1. 指定位上值为1（用于保留位置上的原值）
     2. 其余位置上值为0
3. **判断奇偶数**：
     1. 最末位为1，则为奇数；最末位为0，则为偶数
     2. 所以，将数与1与运算，结果为1，就为奇数；结果为0，就为偶数

### 1.2 按位或运算`|`

运算规则：两位只要有一个为`1`，结果就是为`1`；两位全为`0`，结果才为`0`

### 1.3 按位异或运算`^`

**运算规则**：两位值不同，结果为`1`；两位同时为`0`或`1`，结果为`0`

> 可以理解为**无进位相加**

#### 性质

1. `N ^ 0 = N` `N ^ N = 0`

     >   相同地址的元素之间异或，会使元素变成0

2. 满足结合律和交换律

     + `a ^ b = b ^ a`
     + `a ^ b ^ c = a ^ (b ^ c)`

作用：

1. 清零：拥有相同内存地址的变量之间异或运算，会将变量清零
   1. 可以用于一组数据中去除相同变量
2. 找到数组中唯一奇数个变量：数组中元素挨着异或，会将其他所有偶数个相同的变量异或为零，只剩下奇数个的变量

#### 应用

##### 1 不适用额外变量的元素交换

```c++
void sway(int& a, int& b){
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```

> 注意：**需要保证上述代码中的变量`a`与变量`b`存放在不同的两块内存空间中**

##### 2 一个数出现奇数次

一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数？

```c++
#include <iostream>
using namespace std;

int main() {

    int n, res = 0;;
    scanf("%d",&n);

    while(n > 0){
        int m;
        scanf("%d",&m);
        res ^= m;
        --n;
    }

    printf("%d\n", res);

    return 0;
}
```

##### 3 两个数出现奇数次

一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数？

思路：

1. 设a与b两个数是奇数个数

2. 则，如果将所有数字异或，结果会是`res1 = a^b`
3. 由于`a != b`，则两者一定在某些位上是不同的
4. 这个对应不同的数位，对应在`res1`中，一定为`1`
5. 那么，选择`res1`中为`1`的某一位，将数组分成两份
6. 在每一份上的子数组只包含一个奇数次的数字
7. 那么`res1`如果只和其中一个子数组中的所有数异或
     1. 比如只和数组中这一位上为`1`的元素异或
8. 则能得到`res2`为`a`或`b`的其中一个，假设为`a`
9. 则`b = res1 ^ res2`

关键问题：

1. **提取最右边的1**

 ```c++
 rightOne = res & (~res + 1)
 ```

 >   1. res取反之后，所有位上的数值都会变成相反的
 >   2. 也就是说，右侧所有的0都会变成1
 >   3. `~res+1`，右侧变成1的数会都变成0，一直到`res`右 侧第一个1的位置
 >   4. 这时，`~res+1`数位上会被`res`最右侧的1所在位分成 两半：
 >        + 左侧：与`res`所有数位相反
 >        + 右侧：全是0
 >   5. 所以，`res & (~res + 1)`的结果`rightOne`是， 只剩下`res`最右侧的1位置上为1，其余位置都是0

1. **如何判断数组对应数位上的数值是否为`1`或者`0`**

     用`arr[i]`与`rightOne`进行**与运算**

     + 结果为0，就是`arr[i]`对应数位上为`0`
     + 结果为`rightOne`，就是`arr[i]`对应数位上为`1`

```c++
pair<int, int> TwoNumsSearch(int* arr, int length) {

 //用 firstOne 和 secondOne 保存结果， 用 rightOne 保存最右侧的一
 int firstOne = 0, secondOne = 0, rightOne;

 //求a^b
 for (int i = 0; i < length; ++i) {
  firstOne ^= arr[i];
 }

 //求a^b最右侧的1
 rightOne = firstOne & (~firstOne + 1);

 //求最右侧1对应位为0的变量 设为a
 for (int i = 0; i < length; ++i) {
  if ((rightOne & arr[i]) == 0) { //判断arr[i]在最右侧的1对应位置上的数值为0
   secondOne ^= arr[i];
  }
 }

 //求b
 firstOne ^= secondOne;

 pair<int, int> res = {firstOne, secondOne};

 return res;
}
```

### 1.4 取反运算`~`

运算规则：值为`1`，结果为`0`；值为`0`，结果为`1

作用：

1. 求相反数
   `~num + 1`
   + 若`num`为正数，则求其相反数，负数的补码
   + 若`num`为负数，则求负数补码的补码，得到正数的原码
     + 在二进制中，减一取反和取反加一等价

### 1.5 左移运算`<<`

运算规则：

将补码向左移动`n`位，低位补`0`

> 若高位为`0`，也就是说左移操作不会使高位的`1`溢出舍弃，则**左移相当于为原数乘以2**

### 1.6 右移运算`>>`

运算规则：

非负数数：正数补码，向右移动`n`位，高位补`0`

负数：负数补码向右移动`n`位，高位补`1`

作用:

1. 除以2：右移一位相当于**除以2且向下取整**，$num >> 1 == num / 2$

## 2.原码、补码、反码

### 原码

第一位为符号位，0表示正数，1表示负数，其余为数值位，二进制

### 反码

正数的反码和原码相同

负数的反码，符号位保持不变，其余位置按位取反

### 补码

正数的补码和原码相同

**负数的补码**为，负数对应正数的**原码按位取反再加一，也就是反码加一**

数字在计算机中是以补码的形式存储的

> 对于负数而言，假设负数为`-num`，则其补码为`2^N - 1 - num`
>
> 比如对于一个八位二进制数`-5`而言，其补码为
>
> $$
> \begin{split}
> 2^8 - 1 - 5 &= 1111 1111 - 0000 0101 \\
> \ &= 1111 0010
>  \end{split}
> $$

补码的求解方法：按位取反加一

补码转换成原码：按位取反加一/减一按位取反

> 证明1:
> 按照上述对负数补码的解释
> $$
> \begin{split}
> 补码_1 &= \sim原码 + 1 \\ 『
> \ &= 2^N - 原码 \\
> \end{split}
> $$
> 则，补码的补码为：
> $$
> \begin{split}
> 补码_2 &= \sim补码_1 + 1 \\
> \ &= 2^N - 补码_1 \\
> \ &= 2^N - (2^N - 原码) \\
> \ &= 原码
> \end{split}
> $$
>
> 证明2：
> $$
> \begin{split}
> 补码 &= \sim原码 + 1 \\
> \ &= 2^N - 1 - 原码_1 + 1 \\
> \ & = 2^N - 原码_1 \\
> \end{split}
> $$
> 则：
> $$
> 原码_1 = 2^N - 补码
> $$
> 另：
> $$
> \begin{split}
> 原码_2 &= \sim(补码 - 1) \\
> \ &= 2^N - 1 - (补码 - 1) \\
> \ &= 2^N - 补码 \\
> \ &= 原码_1 \\
> \end{split}
> $$

## 溢出

### 1 什么是溢出

由于硬件规模或者语言规定的限制，存储数据的长度有限，当运算结果超出这个长度时，就会发生溢出

### 2 什么时候不会溢出

1. 相加的两个数字，符号相反
2. 相减的两个数字，符号相同

### 3 怎么知道是否发生溢出

1. 有符号计算
   看符号位，看有无向符号位的进位
   1. 两个正数相加，结果为负数——加法的溢出
   2. 正数减负数，或负数减正数，结果为负数——减法的溢出
2. 无符号计算
   看结果大小
   1. 两个数相加，总和小于加数中的任意一个
   2. 两数相减，结果小于被减数

## 位运算的应用

1. 对于01问题的压缩存储

     比如对于一个人是否做了三件事：事情1、事情2、事情3

     则可以使用一个三位二进制数来存储这个人的状态

     比如：010，代表这个人做了事情2，没有做事情1和事情3

     查看状态：可以通过与100与运算，来判断这个人是否做了事情1

     改变状态：
     1. 可以通过与100进行或运算，改变原本状态为1xx
     2. 可以通过与011进行与运算，改变原本状态为0xx

     事件遍历：for(i=0;i<7;++i)的方式遍历全部状态
